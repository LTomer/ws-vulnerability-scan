import * as taskLib from 'azure-pipelines-task-lib/task';
import * as path from 'path';
import util = require("./util.js");
import api = require("./ws-api.js");
import simpleGit from 'simple-git';
import { DownloadAgent } from './agent';
import { Configuration } from './Configuration';

const VAR_DEFAULT_BRANCH = 'DefaultBranch'
const VAR_MIN_JAVA_HEAP = 'MinJavaHeap'
const VAR_MAX_JAVA_HEAP = 'MaxJavaHeap'

const SOURCE_CONTROL_GIT = 'TfsGit';
const SOURCE_CONTROL_GIT_MASTER = 'master';
const SOURCE_CONTROL_GIT_MAIN = 'main';

async function run() {
    taskLib.setResourcePath(path.join(__dirname, 'task.json'));
    
    let con = new Configuration()
    if(!con.Success)
        return;

    //DEFAULT BRANCH
    const defaultBranch: string = GetDefaultBranch();

    let org = JSON.parse(await api.getOrganizationDetails(con.apiBaseURL, con.apiKey, con.userKey))["orgName"]
    console.log(taskLib.loc("OrgName", org))

    //Check if scan requierd
    let masterProjectName: string = GetWSProject(con.sourceControlType, defaultBranch, con.projectName, con.scanType)
    let isScan: boolean = await isRunScan(con, masterProjectName);

    if(isScan){
        const agentFullName = await DownloadAgent(con.agentUrl, con.downloadAgentDays);
        if(!agentFullName){
            taskLib.error(taskLib.loc("missingAgent"))
            return
        }

        let currentProjectName: string = GetWSProject(con.sourceControlType, con.gitBranchName, con.projectName, con.scanType)
        Scan(agentFullName, con.scanFolder, con.apiKey, con.configFile, con.productName, con.policyViolationMessageType, currentProjectName);

        //Delete old project relevant for GIR repository when its run on master branch.
        if(con.deleteProjectDays > 0 && con.sourceControlType == SOURCE_CONTROL_GIT && IsDefaultBranch(con.gitBranchName)){
            DeleteProject(con.apiBaseURL, con.apiKey, con.userKey, con.productName, masterProjectName, con.deleteProjectDays)
        }
    }
    else{
        console.log('- Scan for vulnerability is not necessary')
    }
}

function GetDefaultBranch(){
    let branchName: string = taskLib.getInput(VAR_DEFAULT_BRANCH, false) || ''
    return branchName.trim()
}

function IsDefaultBranch(branchName: string){
    let defaultBranch: string = GetDefaultBranch()
    return (defaultBranch == '' && (branchName == SOURCE_CONTROL_GIT_MAIN || branchName == SOURCE_CONTROL_GIT_MASTER)) || branchName == defaultBranch
}

async function DeleteProject(apiBaseUrl: string, apiKey: string, userKey: string, product: string, project: string, days: number) {
    if(!userKey){
        console.log("Set UserKey for delete an old projects")
        return
    }
    let productToken = await api.getProductToken(apiBaseUrl, apiKey, userKey, product)
    
    if(productToken == undefined){
        console.log('- product token does not exist.')
        return
    }

    let projectNameRegex = `^${project}[(]+`;
    await api.deleteProjectScanedBeforeDays(apiBaseUrl, userKey, productToken, days, false, projectNameRegex)
}

function GetWSProject(sourcecontrol_type: string, gitBranchName: string, project: string, scanType: string) {
    if(sourcecontrol_type != SOURCE_CONTROL_GIT)
        return project;

    if(IsDefaultBranch(gitBranchName))
        return project;

    if(scanType == 'OneProjectForAllBranch')
        return project;

    return `${project}(${gitBranchName})`;
}

async function isRunScan(con: Configuration, masterProjectName: string) {
    if(con.sourceControlType != SOURCE_CONTROL_GIT){
        console.log(taskLib.loc("ScanReasonNotGit"))
        return true
    }
    
    if(IsDefaultBranch(con.gitBranchName)){
        console.log(taskLib.loc("ScanReasonMaster"))
        return true
    }

    //check if the current branch is in the list of branches (long term branches)
    if(con.listOfBranches.split(',').includes(con.gitBranchName)){
        console.log(taskLib.loc("ScanReasonExistOnList"))
        return true
    }

    if(con.scanType == 'ScanLongTermBranches'){
        console.log(taskLib.loc("ScanLongTermBranches"))
        return false
    }
    
    let packageListChanged = await GitDiffWith(`remotes/origin/${GetDefaultBranch()}`, con.packagesFilePattern)
    if(packageListChanged){
        return true
    }
    
    let productToken: string = await api.getProductToken(con.apiBaseURL, con.apiKey, con.userKey, con.productName);
    if (productToken == undefined){
        console.log(taskLib.loc("ScanReasonNoProduct"))
        return true
    }
    
    let projectTokenMaster: string = await api.getProjectToken(con.apiBaseURL, con.userKey, productToken, masterProjectName);
    if (projectTokenMaster == undefined){
        console.log(taskLib.loc("ScanReasonNoMasterScan"))
        return true
    }
    
    let resVulnerabilityReport = await api.getProjectVulnerabilityReport(con.apiBaseURL, con.userKey, projectTokenMaster)
    let objVulnerabilityReport = JSON.parse(resVulnerabilityReport)

    let lastScanOnMasterFailed = objVulnerabilityReport.vulnerabilities.length > 0
    if(lastScanOnMasterFailed){
        console.log(taskLib.loc("ScanReasonNotVulnerability"))
        return true
    }
    
    let resProjectVitals = await api.getProjectVitals(con.apiBaseURL, con.userKey, projectTokenMaster)
    let objProjectVitals = JSON.parse(resProjectVitals)
    let lastUpdate = objProjectVitals.projectVitals[0]['lastUpdatedDate']
    let daysSince = util.daysSince(lastUpdate)
    if(daysSince > con.scanExpired || daysSince < 0){
        console.log(taskLib.loc("ScanReasonExpiredScan"))
        return true
    }

    return false
}

//return false if it equal other return true (not equal, error, git not installed)
async function GitDiffWith(branchName: string, filePattern: string) {
    if (typeof filePattern == "undefined" || filePattern == null || filePattern.trim() == ""){
        console.log(taskLib.loc("ScanReasonPatternMissing"))
        return true
    }

    var commandExistsSync = require('command-exists').sync;
    let isGitExist = commandExistsSync('git')
    if(!isGitExist){
        console.log(taskLib.loc("ScanReasonGitMissing"))
        return true
    }

    const gitSourceDirectory: string = taskLib.getVariable('BUILD_SOURCESDIRECTORY') || ''
    if(!gitSourceDirectory){
        console.log(taskLib.loc("ScanReasonDirectoryMissing"))
        return true
    }

    let flag = GitRepoConditions(branchName, filePattern, gitSourceDirectory)
    if (flag != undefined)
        return flag

    return false
}

async function GitRepoConditions(branchName: string, filePattern: string, gitSourceDirectory: string) {
    const git = simpleGit(gitSourceDirectory);

    if(branchName == '' || branchName.endsWith('/')){
        try{
            let initResult = await git.raw(["branch", "--all"])
            var re_master = new RegExp(`\/${SOURCE_CONTROL_GIT_MASTER}$`, "mi");//multilines, insensitive
    
            var match_master = re_master.exec(initResult)
            if(match_master){
                branchName += SOURCE_CONTROL_GIT_MASTER
            }
            else{
                var re_main = new RegExp(`\/${SOURCE_CONTROL_GIT_MAIN}$`, "mi");//multilines, insensitive
    
                var match_main = re_main.exec(initResult)
                if(match_main){
                    branchName += SOURCE_CONTROL_GIT_MAIN
                }
                else{
                    console.log(taskLib.loc("ScanReasonDefaultBranchUnknown"))
                    return true
                }
            }
            console.log(taskLib.loc("DefaultBranch", branchName))
        }
        catch (e) { 
            console.log(e)
            console.log(taskLib.loc("ScanReasonDefaultBranchFailed"))
            return true
        }
    }

    try {
        var re = new RegExp(filePattern, "mi");//multilines, insensitive 
        let initResult = await git.raw(["diff", "--name-only", branchName])
        let val = initResult.replace('\\','/').trim()

        var m1 = re.exec(val);
        if (m1){
            console.log(taskLib.loc("ScanReasonDiff"))
            return true
        }
    }
    catch (e) { 
        console.log(e)
        console.log(taskLib.loc("ScanReasonDiffFailed"))
        return true
    }

    try {
        let initResult = await git.raw(["ls-tree", "-r", "--name-only", branchName])
        let val = initResult.replace('\\','/').trim()

        var m2 = re.exec(val);
        if (!m2){
            console.log(taskLib.loc("ScanReasonPatternNotValid"))
            return true
        }
    }
    catch (e) { 
        console.log(e)
        console.log(taskLib.loc("ScanReasonDiffFailed"))
        return true
    }
    
    return undefined
}

function Scan(agentFullName: string, scanFolder: string, apiKey: string, configFile: string, productName: string, messageType: string, wsProjectName: string) {
    try {
        console.log("====== RUN WS AGENT ======")

        let memoryParam = GetJavaMemoryParams()

        let res = taskLib.execSync('java', `-jar ${memoryParam} ${agentFullName} -d ${scanFolder} -apiKey ${apiKey} -c ${configFile} productName ${productName} projectName ${wsProjectName}`);
    
        if(res.code != 0){
            let errCode = res.code % 256
            if( errCode == 254){
                let taskRes = messageType == "failed" ? taskLib.TaskResult.Failed  : taskLib.TaskResult.SucceededWithIssues
                taskLib.setResult(taskRes, taskLib.loc("PolicyViolations"));
            }
            else
                taskLib.setResult(taskLib.TaskResult.Failed, taskLib.loc("AgentFailed", res.code, errCode, res.error));
            return;
        }
    }
    catch (err) {
        let err_msg = "Scan failed, error unknown"
        if(err instanceof Error)
            err_msg = err.message
        
        taskLib.setResult(taskLib.TaskResult.Failed, err_msg);
    }
}

function GetJavaMemoryParams(): string{
    let minJavaHeap: string = (taskLib.getInput(VAR_MIN_JAVA_HEAP, false) || '').trim();
    let maxJavaHeap: string = (taskLib.getInput(VAR_MAX_JAVA_HEAP, false) || '').trim();

    let memoryParam: string = ""
    if(minJavaHeap)
        memoryParam += '-Xms' + minJavaHeap
    if(maxJavaHeap)
        memoryParam += ' -Xmx' + maxJavaHeap
    
    return memoryParam;
}

run();
